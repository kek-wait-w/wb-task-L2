package pattern

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/

type Product interface {
	Use() string
}

type ConcreteProductA struct{}

func (cpa *ConcreteProductA) Use() string {
	return "Используется продукт A"
}

type ConcreteProductB struct{}

func (cpb *ConcreteProductB) Use() string {
	return "Используется продукт B"
}

type Factory interface {
	CreateProduct() Product
}

type ConcreteFactoryA struct{}

func (cfa *ConcreteFactoryA) CreateProduct() Product {
	return &ConcreteProductA{}
}

type ConcreteFactoryB struct{}

func (cfb *ConcreteFactoryB) CreateProduct() Product {
	return &ConcreteProductB{}
}

/*
Применимость паттерна:
Когда у вас есть общий интерфейс для создания объектов, но конкретный класс создаваемого объекта должен определяться на уровне подклассов.
Когда вы хотите избежать зависимости создающего кода от классов создаваемых объектов.
Когда создание объекта требует выполнения дополнительной логики.

Плюсы:
Позволяет изолировать создание объектов от их использования.
Облегчает добавление новых типов объектов без изменения существующего кода.

Минусы:
Может привести к созданию большого количества подклассов, что усложняет структуру программы.
Усложняет понимание программы из-за неявной связи между создающим и создаваемым объектом.

Примеры использования:
В фреймворках для создания пользовательских интерфейсов, где различные элементы интерфейса могут иметь различные фабричные методы для их создания (например, кнопки, текстовые поля и т. д.).
В игровых движках для создания различных типов объектов в игровом мире (например, персонажи, оружие, предметы и т. д.).
В библиотеках для работы с базами данных, где разные типы запросов могут использовать различные фабричные методы для создания объектов запросов.
*/
