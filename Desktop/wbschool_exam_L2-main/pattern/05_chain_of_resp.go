package pattern

import "fmt"

/*
	Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
*/

type Handler interface {
	handle(request int)
	setNext(handler Handler)
}

type BaseHandler struct {
	nextHandler Handler
}

func (bh *BaseHandler) setNext(handler Handler) {
	bh.nextHandler = handler
}

type Handler1 struct {
	BaseHandler
}

func (h *Handler1) handle(request int) {
	if request <= 10 {
		fmt.Println("Handler1 обрабатывает запрос", request)
	} else if h.nextHandler != nil {
		h.nextHandler.handle(request)
	}
}

type Handler2 struct {
	BaseHandler
}

func (h *Handler2) handle(request int) {
	if request <= 20 {
		fmt.Println("Handler2 обрабатывает запрос", request)
	} else if h.nextHandler != nil {
		h.nextHandler.handle(request)
	}
}

type Handler3 struct {
	BaseHandler
}

func (h *Handler3) handle(request int) {
	if request <= 30 {
		fmt.Println("Handler3 обрабатывает запрос", request)
	} else {
		fmt.Println("Ни один обработчик не может обработать запрос", request)
	}
}

/*
Применимость паттерна:
Когда у вас есть несколько объектов, которые могут обработать запрос, и вы не хотите знать, какой конкретно объект его обработает.
Когда набор объектов и способ их обработки может изменяться динамически во время выполнения программы.
Когда вам нужно обработать запрос в определенном порядке.

Плюсы:
Уменьшение зависимости между отправителем запроса и его получателем.
Гибкость в добавлении новых обработчиков или изменении порядка существующих.
Позволяет избежать жестких связей между отправителем запроса и его получателем.

Минусы:
Не гарантирует, что запрос будет обработан. Если ни один из обработчиков не сможет обработать запрос, то он останется необработанным.
Может привести к дополнительным накладным расходам из-за прохода через всю цепочку обработчиков.

Примеры использования:
Обработка запросов HTTP в веб-фреймворках, где запрос может быть обработан разными по мере роста.
Обработка событий пользовательского интерфейса в графических редакторах, где каждый элемент интерфейса может обрабатывать события независимо.
Паттерн «цепочка вызовов» помогает создавать гибкие и расширяемые системы, где каждый компонент выполняет свою четко определенную задачу, а цепочка их связывает для обработки запросов в удобном порядке.
*/
